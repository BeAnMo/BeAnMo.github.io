<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Traversing JSON</title><link href="https://fonts.googleapis.com/css2?family=Merriweather&family=Montserrat&family=Source+Code+Pro&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><style>body{margin:0;padding:0;font-size:1.1rem;font-weight:500;font-family:Montserrat,-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;background-color:#fbfbfb;color:#444}h1,h2,h3,h4,h5,h6{font-family:Merriweather,serif;margin:1rem 0}p{margin:1rem 0}pre{background-color:#eee;padding:.5rem;width:100%;overflow:auto;line-height:1rem}code{font-family:Source Code Pro,monospace;color:#00a19c}a{color:#0083c1}a:hover{color:#00a19c}a:active{color:#f98e2c}a:visited{color:#ce112d}</style><link rel="stylesheet" href="/assets/css/main.css"><link rel="stylesheet" href="/assets/css/prism-theme.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-178156821-2"></script><script>window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-178156821-2');</script></head><body><nav class="navbar"><h3><a href="/#about-me">Benjamin Morin</a></h3><div class="navbar-links"></div></nav><main class="container"><article class="content"><header><h3 style="margin-bottom: 0;">Traversing JSON</h3><h6 style="margin-top: 0;" class="lt-text">Tue Oct 06 2020</h6></header><section><div class="post-body"><p>Given the ubiquity of <a href="https://www.json.org/" target="_blank" rel="noopener">JavaScript Object Notation</a> on the internet and beyond, one should have an understanding of dealing with arbitrarily nested data. Web developers get the <a href="https://www.json.org/" target="_blank" rel="noopener">Document Object Model</a>, which turns boring HTML text into a living object that can be traversed and manipulated. However, there is not an standard equivalent for JSON. Luckily, JSON is far easier to deal with the raw HTML and with some basic procedures, can be transformed at the programmers whim.</p><h3>Don't Just Curse, <em>Recurse</em></h3><p>JSON is self-referential, which means it defines itself in part by referring to itself. A brief description of valid JSON is:</p><pre class="language-js"><code class="language-js"><span class="token constant">JSON</span> is one <span class="token keyword">of</span><span class="token operator">:</span><br><span class="token operator">-</span> <span class="token keyword">null</span><br><span class="token operator">-</span> boolean<br><span class="token operator">-</span> number<br><span class="token operator">-</span> string<br><span class="token operator">-</span> Object<br><span class="token operator">-</span> Array</code></pre><p>Notice there are 4 primitive* types of data and 2 compound ones. If there's JSON that contains an array, what's in the array? JSON, of course. Likewise, each object key points to more JSON. So a slightly fuller description is:</p><pre class="language-js"><code class="language-js"><span class="token constant">JSON</span> is one <span class="token keyword">of</span><span class="token operator">:</span><br><span class="token operator">-</span> <span class="token keyword">null</span><br><span class="token operator">-</span> boolean<br><span class="token operator">-</span> number<br><span class="token operator">-</span> string<br><span class="token operator">-</span> Object <span class="token keyword">of</span><span class="token operator">:</span><br>    <span class="token operator">-</span> string<span class="token operator">:</span> <span class="token constant">JSON</span><br><span class="token operator">-</span> Array <span class="token keyword">of</span><span class="token operator">:</span><br>    <span class="token operator">-</span> <span class="token constant">JSON</span></code></pre><p>Each one of those values (however nested) are valid JSON.</p><p>How can this knowledge used to an advantage? When traversing JSON, if one of the primitive data types are encountered, they can be handled immediately. If a string is encountered, do something with it. When designing a recursive algorithm, this can be used as a base case.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Halfway there, kind of. The function <code>next</code> is some hypothetical way to advance to the next JSON element. How would that be determined though? If each array and object ultimately reduces to 1 of the 4 primitive types, then there is a need to traverse both structures.</p><p>To start, it is a good idea to know whether JSON is an object or an array, so two predicate functions will be introduced to simplify things:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> item <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">&amp;&amp;</span> item <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Nice and easy, but these will reduce some of the clutter. How about traversing a JSON array? JS has no shortage of ways to do that:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">traverseArray</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">traverse</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> results<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>It simply maps <code>traverse</code> to each element in the array. <code>traverse</code> was never completed but leaving that as is for now allows abstracting away independent traversals. For the time being, the assumption is that <code>traverse</code> will return something, its details are not important yet. How about object traversals? Basically the same thing:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">traverseObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">traverse</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">return</span> results<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Revisiting <code>traverse</code> now allows all the pieces to be assembled.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token function">traverseArray</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token function">traverseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token string">'found a string'</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Passing in some test data:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><br>  id<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span><br>  records<span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>      sub_id<span class="token operator">:</span> <span class="token number">3</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token punctuation">{</span><br>      sub_id<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span><br>      name<span class="token operator">:</span> <span class="token string">'whut?'</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Would return:</p><pre class="language-js"><code class="language-js"><span class="token punctuation">[</span><br>  <span class="token keyword">null</span><span class="token punctuation">,</span><br>  <span class="token punctuation">[</span><br>    <span class="token punctuation">[</span><br>      <span class="token keyword">null</span><br>    <span class="token punctuation">]</span><span class="token punctuation">,</span><br>    <span class="token punctuation">[</span><br>      <span class="token keyword">null</span><span class="token punctuation">,</span><br>      <span class="token string">"found a string"</span><br>    <span class="token punctuation">]</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">]</span></code></pre><p>That's not exciting. But it does show a very basic mapping process utilizing a depth first approach.</p><hr><p>Ideas:</p><ul><li>recursion<ul><li>needed to traverse arbitraliy nested objects/arrays</li><li>mutual recursion for handling objects in arrays &amp; arrays in objects</li></ul></li><li>depth first<ul><li>pros:<ul><li>easy to do with mutal recursion/generators</li></ul></li><li>cons:<ul><li>performance relative to breadth first</li></ul></li></ul></li><li>breadth first<ul><li>pros:<ul><li>performance</li></ul></li><li>cons:<ul><li>have to rely on queue, increases the complexity</li></ul></li></ul></li><li>generators/streams<ul><li>pros:<ul><li>easy to do/drastically simplify code</li><li>lazy evaluation</li></ul></li><li>cons:<ul><li>don't play well with Babel/questionable support on older browsers</li><li>performance hit over loops</li></ul></li></ul></li><li>data processing - grouping on specific keys/levels - filtering (&quot;pruning&quot;) - mapping over specific keys</li></ul></div></section></article></main><footer class="container" style="height: 4rem;"><div class="content" style="display: flex; justify-content: flex-end;"><h5>&copy; 2020 Benjamin Morin</h5></div></footer></body></html>